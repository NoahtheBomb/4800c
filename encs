#pragma config(Sensor, dgtl1,  brEnc,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  frEnc,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  flEnc,          sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  blEnc,          sensorQuadEncoder)
#pragma config(Motor,  port2,           flWheel,       tmotorVex393TurboSpeed_MC29, openLoop, driveLeft, encoderPort, dgtl5)
#pragma config(Motor,  port3,           frWheel,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port4,           blWheel,       tmotorVex393TurboSpeed_MC29, openLoop, driveLeft, encoderPort, dgtl7)
#pragma config(Motor,  port5,           brWheel,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveRight, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ROT vexRT[Ch1]
#define Y_AXIS vexRT[Ch3]
#define STRAFE vexRT[Ch4]

typedef struct Encoder {
	int val,
		valLast,
		delta;
	tSensors name;
} enc;

enc fl,
	bl,
	br,
	fr;

const float convertToRadians = PI / 180;
	
float x = 0,
	y = 0,
	r = 0;

task main()	{

	fl.name = flEnc;
	bl.name = blEnc;
	br.name = brEnc;
	fr.name = frEnc;
	
	fl.valLast =
		bl.valLast =
		br.valLast =
		fr.valLast =
		fr.val =
		bl.val =
		br.val =
		fr.val =
		0;

	while(true) {

		fl.valLast = fl.val;
		bl.valLast = bl.val;
		br.valLast = br.val;
		fr.valLast = fr.val;

		fl.val = SensorValue[fl.name];
		bl.val = SensorValue[bl.name];
		br.val = SensorValue[br.name];
		fr.val = SensorValue[fr.name];

		motor[flWheel] = Y_AXIS + ROT + STRAFE;
		motor[frWheel] = Y_AXIS - ROT - STRAFE;
		motor[blWheel] = Y_AXIS + ROT - STRAFE;
		motor[brWheel] = Y_AXIS - ROT + STRAFE;

		r += ((fl.delta + bl.delta) - (fr.delta + br.delta)) / 2;
		
		y += sin(r * convertToRadians) * (fl.delta + bl.delta + fr.delta + br.delta) / 4;
		
		wait1Msec(20);
	}
}
