#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  rDriveEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  lDriveEnc,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           frDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port3,           flDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port8,           blDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port9,           brDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SAMPLE_SIZE 10

#define RX vexRT[Ch1]
#define RY vexRT[Ch2]
#define LY vexRT[Ch3]
#define LX vexRT[Ch4]

#define STICK_THRESH 7

float
	gyroDrift,
	vel[SAMPLE_SIZE],
	deltaTheta[SAMPLE_SIZE],
	lVel,
	rVel,
	velAvg = 0,
	deltaThetaAvg = 0,
	thetaLast = 0,
	xPos = 0,
	yPos = 0,
	theta = 0,
	stickRX = 0,
	stickLY = 0;

int lEnc = 0,
	lEncLast,
	rEnc = 0,
	rEncLast,
	thetaTime = 0,
	thetaTimeLast;

void setRDrive(float pwr) {
	motor[frDrive] =
		motor[brDrive] =
		pwr;
}

void setLDrive(float pwr) {
	motor[flDrive] =
		motor[blDrive] =
		pwr;
}

void arcadeDrive(float x, float y) {
	setRDrive(y - x);
	setLDrive(y + x);
}

task main() {
	SensorFullCount[gyro] = 2147483647;
	for(int i = 0; i < SAMPLE_SIZE; i++) {
		vel[i] =
			deltaTheta[i] =
			0;
	}

	while(true) {

		lEncLast = lEnc;
		rEncLast = rEnc;
		thetaLast = theta;
		thetaTimeLast = thetaTime;

		for(int i = SAMPLE_SIZE - 1; i > 0; i--) {
			vel[i] = vel[i-1];
			deltaTheta[i] = deltaTheta[i-1];
		}


		hogCPU();
		lEnc = SensorValue[lDriveEnc];
		rEnc = SensorValue[rDriveEnc];
		releaseCPU();

		lVel = 1.0 * lEnc - lEncLast;
		rVel = 1.0 * rEnc - rEncLast;

		vel[0] = 0.5 * (lVel + rVel);


		hogCPU();
		theta = SensorValue[gyro];
		thetaTime = nSysTime;
		releaseCPU();

		deltaTheta[0] = (theta - thetaLast);
		if((deltaTheta[0]  / (thetaTime - thetaTimeLast)) < gyroDrift)
			deltaTheta[0] = 0;

		velAvg =
			deltaThetaAvg =
			0;
		for(int i = 0; i < SAMPLE_SIZE; i++) {
			velAvg += vel[i];
			deltaThetaAvg += deltaTheta[i];
		}
		velAvg /= SAMPLE_SIZE;
		deltaThetaAvg /= SAMPLE_SIZE;

		theta += deltaThetaAvg;

		xPos += velAvg * sin(theta * PI / 180);
		yPos += velAvg * cos(theta * PI / 180);

		if(fabs(RX) > STICK_THRESH)
			stickRX = RX;
		else
			stickRX = 0;

		if(fabs(LY) > STICK_THRESH)
			stickLY = LY;
		else
			stickLY = 0;

		arcadeDrive(stickRX, stickLY);
	}
}
